{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment Documenta\'E7\'E3o Projeto de Engenharia 2  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}Documenta\'E7\'E3o Projeto de Engenharia 2}
{\comment Gerado por doxygen 1.9.7.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Documenta\'E7\'E3o Projeto de Engenharia 2}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Vers\'E3o 1.0\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Sum\'E1rio\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos Componentes\par \pard\plain 
{\tc \v \'CDndice dos Componentes}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de Classes\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Aqui est\'E3o as classes, estruturas, uni\'F5es e interfaces e suas respectivas descri\'E7\'F5es:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Complex} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos Arquivos\par \pard\plain 
{\tc \v \'CDndice dos Arquivos}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de Arquivos\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Esta \'E9 a lista de todos os arquivos e suas respectivas descri\'E7\'F5es:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b D:/proj de engenharia/EngineeringProject2/{\b atividade_1.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b D:/proj de engenharia/EngineeringProject2/{\b main.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b D:/proj de engenharia/EngineeringProject2/{\b matrizes.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b D:/proj de engenharia/EngineeringProject2/{\b matrizes.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Classes{\tc \v Classes}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Complex\par \pard\plain 
{\tc\tcl2 \v Complex}
{\xe \v Complex}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
\par
{
{\f2 #include <matrizes.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b real}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b img}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v img\:Complex}
{\xe \v Complex\:img}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Complex::img}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v real\:Complex}
{\xe \v Complex\:real}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Complex::real}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
D:/proj de engenharia/EngineeringProject2/{\b matrizes.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Arquivos{\tc \v Arquivos}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo D:/proj de engenharia/EngineeringProject2/atividade_1.c\par \pard\plain 
{\tc\tcl2 \v D:/proj de engenharia/EngineeringProject2/atividade_1.c}
{\xe \v D:/proj de engenharia/EngineeringProject2/atividade_1.c}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v main\:atividade_1.c}
{\xe \v atividade_1.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5 \{\par
6     {\cf18 char} str[]= {\cf22 "NOME DO ALUNO"};\par
7 \par
8     {\cf20 //nome aqui}\par
9     {\cf18 char} name1[]= {\cf22 "LUCAS ALEXSANDRO LEAL DOS SANTOS;"};\par
10     {\cf18 char} name2[]= {\cf22 "GABRIEL DE JESUS DOS SANTOS COSTA;"};\par
11     {\cf18 char} name3[]= {\cf22 "SAULO MATTHEUS RIBEIRO DE OLIVEIRA;"};\par
12     {\cf18 char} name4[]= {\cf22 "JOSE HENRIQUE BARBOSA PENA;"};\par
13 \par
14     {\cf18 char} str2[]= {\cf22 "MATRICULA"};\par
15 \par
16     {\cf20 //matricula aqui}\par
17     {\cf18 char} * matri1= {\cf22 "(202207040035)"};\par
18     {\cf18 char} * matri2= {\cf22 "(202206840044)"};\par
19     {\cf18 char} * matri3= {\cf22 "(202206840041)"};\par
20     {\cf18 char} * matri4= {\cf22 "(202206840036)"};\par
21 \par
22     {\cf18 char} divisoria[]= {\cf22 "------------------------------------"};\par
23     {\cf18 char} divisoria2[]= {\cf22 " --------------"};\par
24 \par
25     printf({\cf22 " \\t %s \\t"}, str);\par
26     printf({\cf22 "\\t\\t %s \\n\\n"}, str2);\par
27     printf({\cf22 "%s \\t"}, divisoria);\par
28     printf({\cf22 "%s \\n"}, divisoria2);\par
29     printf({\cf22 "%s \\t %s \\n"}, name1, matri1);\par
30     printf({\cf22 "%s \\t %s \\n"}, name2, matri2);\par
31     printf({\cf22 "%s \\t %s \\n"}, name3, matri3);\par
32     printf({\cf22 "%s \\t %s \\n"}, name4, matri4);\par
33     \par
34     {\cf20 //eh okay}\par
35     \par
36     {\cf19 return} 0;\par
37 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo D:/proj de engenharia/EngineeringProject2/main.c\par \pard\plain 
{\tc\tcl2 \v D:/proj de engenharia/EngineeringProject2/main.c}
{\xe \v D:/proj de engenharia/EngineeringProject2/main.c}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "matrizes.c"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v main\:main.c}
{\xe \v main.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6 \{\par
7     teste_todos();\par
8     {\cf19 return} 0;\par
9 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo D:/proj de engenharia/EngineeringProject2/matrizes.c\par \pard\plain 
{\tc\tcl2 \v D:/proj de engenharia/EngineeringProject2/matrizes.c}
{\xe \v D:/proj de engenharia/EngineeringProject2/matrizes.c}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "matrizes.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b teste_produto_matricial} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b print_name} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} ** {\b soma} (struct {\b Complex} **matrix1, struct {\b Complex} **matrix2, int linhas, int colunas)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b teste_soma} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} ** {\b subtracao} (struct {\b Complex} **matrix1, struct {\b Complex} **matrix2, int linhas, int colunas)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b teste_subtracao} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} ** {\b transposta} (struct {\b Complex} **matrix1, int linhas, int colunas)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b teste_transposta} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} ** {\b conjugado} (struct {\b Complex} **matrix1, int linhas, int colunas)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b teste_conjugada} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} ** {\b hermitiano} (struct {\b Complex} **matrix1, int linhas, int colunas)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b teste_hermitiano} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} {\b produto_escalar} (struct {\b Complex} *vet1, struct {\b Complex} *vet2, int neu, int nev)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b teste_produto_escalar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} {\b somanc} (struct {\b Complex} a, struct {\b Complex} b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} {\b multiplicacao} (struct {\b Complex} x, struct {\b Complex} y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} ** {\b produto_matricial} (struct {\b Complex} **matrix1, struct {\b Complex} **matrix2, int linhas, int colunas)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b teste_todos} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v conjugado\:matrizes.c}
{\xe \v matrizes.c\:conjugado}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} ** conjugado (struct {\b Complex} **  {\i matrix1}, int  {\i linhas}, int  {\i colunas})}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 382 \{\par
383    {\cf17 struct }Complex **rmtx;\par
384    {\cf18 int} i,j;\par
385 \par
386     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
387     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
388     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
389         rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
390     \}\par
391 \par
392    {\cf19 for}(i = 0; i < linhas; i++)\par
393    \{\par
394        {\cf19 for}(j = 0; j < colunas; j++)\par
395        \{\par
396            rmtx[i][j].real = matrix1[i][j].real;\par
397            rmtx[i][j].img = matrix1[i][j].img * (-1);\par
398        \}\par
399    \}\par
400    {\cf19 return} rmtx;\par
401 \}\par
}
}
{\xe \v hermitiano\:matrizes.c}
{\xe \v matrizes.c\:hermitiano}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} ** hermitiano (struct {\b Complex} **  {\i matrix1}, int  {\i linhas}, int  {\i colunas})}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 481 \{\par
482    {\cf17 struct }Complex **rmtx, **aux;\par
483    {\cf18 int} i,j;\par
484 \par
485     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
486     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
487     aux = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
488 \par
489     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
490          rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
491          aux[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
492     \}\par
493 \par
494    {\cf19 for}(i = 0; i < linhas; i++)\par
495    \{\par
496        {\cf19 for}(j = 0; j < colunas; j++)\par
497        \{\par
498            aux=transposta(matrix1,linhas,colunas);\par
499            rmtx=conjugado(aux,linhas,colunas);\par
500        \}\par
501    \}\par
502    {\cf19 return} rmtx;\par
503 \}\par
}
}
{\xe \v multiplicacao\:matrizes.c}
{\xe \v matrizes.c\:multiplicacao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} multiplicacao (struct {\b Complex}  {\i x}, struct {\b Complex}  {\i y})}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 694 \{\par
695     {\cf17 struct }Complex rmtx;\par
696 \par
697     {\cf20 // multiplicar as matrizes}\par
698     {\cf19 for}({\cf18 int} i=0; i<1; i++)\{\par
699             rmtx.real = (x.real * y.real) + (x.img * y.img) * (-1);\par
700             rmtx.img = (x.real * y.img)  +  (x.img * y.real);\par
701     \}\par
702 \par
703     {\cf19 return} rmtx;\par
704 \}\par
}
}
{\xe \v print_name\:matrizes.c}
{\xe \v matrizes.c\:print_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
print_name ()}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11 \{\par
12     printf({\cf22 "=====Equipe=====\\n\\n"});\par
13 \par
14         {\cf18 char} name1[]= {\cf22 "LUCAS ALEXSANDRO LEAL DOS SANTOS"};\par
15         {\cf18 char} name2[]= {\cf22 "GABRIEL DE JESUS DOS SANTOS COSTA"};\par
16         {\cf18 char} name3[]= {\cf22 "SAULO MATTHEUS RIBEIRO DE OLIVEIRA"};\par
17         {\cf18 char} name4[]= {\cf22 "JOSE HENRIQUE BARBOSA PENA"};\par
18 \par
19         printf({\cf22 " %s\\n %s\\n %s\\n %s\\n\\n"}, name1,name2, name3, name4);\par
20 \}\par
}
}
{\xe \v produto_escalar\:matrizes.c}
{\xe \v matrizes.c\:produto_escalar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} produto_escalar (struct {\b Complex} *  {\i vet1}, struct {\b Complex} *  {\i vet2}, int  {\i neu}, int  {\i nev})}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 582                                                                                            \{\par
583 {\cf17 struct }Complex rmtx, aux;\par
584 \par
585     rmtx.real= 0;\par
586     rmtx.img= 0;\par
587 \par
588     {\cf19 if}(neu == nev)\{\par
589     {\cf20 // multiplicar as matrizes}\par
590     {\cf19 for}({\cf18 int} i=0; i<neu; i++)\{\par
591             aux = multiplicacao(vet1[i],vet2[i]);\par
592             rmtx.real = rmtx.real + aux.real;\par
593             rmtx.img = rmtx.img + aux.img;\par
594             \}\par
595         \}\par
596      {\cf19 else}\{\par
597             printf({\cf22 "ERRO!\\n\\n"});\par
598             printf({\cf22 "O produto escalar nao pode ser calculado porque entre estes vetores pois o numero de elementos dos vetores nao coincidem.\\n\\n"});\par
599     \}\par
600 \par
601 \par
602     {\cf19 return} rmtx;\par
603 \}\par
}
}
{\xe \v produto_matricial\:matrizes.c}
{\xe \v matrizes.c\:produto_matricial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} ** produto_matricial (struct {\b Complex} **  {\i matrix1}, struct {\b Complex} **  {\i matrix2}, int  {\i linhas}, int  {\i colunas})}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 707 \{\par
708     {\cf17 struct }Complex **rmtx, aux, sum;\par
709 \par
710     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
711     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
712 \par
713     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
714         rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
715 \par
716     \}\par
717 \par
718     {\cf19 if}(linhas==colunas)\{\par
719 \par
720     {\cf20 // somar as matrizes}\par
721     {\cf19 for} ({\cf18 int} i = 0; i < linhas; i++) \{\par
722     {\cf19 for} ({\cf18 int} j = 0; j < colunas; j++) \{\par
723         sum.real = 0;\par
724         sum.img = 0;\par
725         {\cf19 for} ({\cf18 int} k = 0; k < colunas; k++) \{\par
726             aux = multiplicacao(matrix1[i][k], matrix2[k][j]);\par
727             sum = somanc(sum, aux);\par
728         \}\par
729         rmtx[i][j] = sum;\par
730     \}\par
731     \}\par
732     \}\par
733     {\cf19 else}\{\par
734 \par
735             printf({\cf22 "ERRO!\\n\\n"});\par
736             printf({\cf22 "A operacao de Produto Matricial nao pode ser iniciada porque o numero de linhas e colunas nao coincidem.\\n\\n"});\par
737 \par
738         \}\par
739     {\cf19 return} rmtx;\par
740 \}\par
}
}
{\xe \v soma\:matrizes.c}
{\xe \v matrizes.c\:soma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} ** soma (struct {\b Complex} **  {\i matrix1}, struct {\b Complex} **  {\i matrix2}, int  {\i linhas}, int  {\i colunas})}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23 \{\par
24 \par
25     {\cf17 struct }Complex **rmtx;\par
26     {\cf19 if}(linhas == colunas)\{\par
27     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
28     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
29     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
30         rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
31     \}\par
32 \par
33     {\cf20 // somar as matrizes}\par
34 \par
35     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
36         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
37             rmtx[i][j].real = matrix1[i][j].real + matrix2[i][j].real;\par
38             rmtx[i][j].img = matrix1[i][j].img + matrix2[i][j].img;\par
39         \}\par
40       \}\par
41     \}\par
42     {\cf19 return} rmtx;\par
43 \par
44 \}\par
}
}
{\xe \v somanc\:matrizes.c}
{\xe \v matrizes.c\:somanc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} somanc (struct {\b Complex}  {\i a}, struct {\b Complex}  {\i b})}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 683                                                          \{\par
684 \par
685     {\cf17 struct }Complex result;\par
686 \par
687     result.real = a.real + b.real;\par
688     result.img = a.img + b.img;\par
689 \par
690     {\cf19 return} result;\par
691 \}\par
}
}
{\xe \v subtracao\:matrizes.c}
{\xe \v matrizes.c\:subtracao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} ** subtracao (struct {\b Complex} **  {\i matrix1}, struct {\b Complex} **  {\i matrix2}, int  {\i linhas}, int  {\i colunas})}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 156 \{\par
157     {\cf17 struct }Complex **rmtx;\par
158     {\cf19 if}(linhas == colunas)\{\par
159     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
160     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
161     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
162         rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
163     \}\par
164 \par
165     {\cf20 // somar as matrizes}\par
166     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
167         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
168             rmtx[i][j].real = matrix1[i][j].real - matrix2[i][j].real;\par
169             rmtx[i][j].img = matrix1[i][j].img - matrix2[i][j].img;\par
170         \}\par
171     \}\par
172     \}\par
173     {\cf19 return} rmtx;\par
174 \}\par
}
}
{\xe \v teste_conjugada\:matrizes.c}
{\xe \v matrizes.c\:teste_conjugada}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int teste_conjugada ()}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 404 \{\par
405     {\cf18 int} linhas = 3;\par
406     {\cf18 int} colunas = 3;\par
407     {\cf17 struct }Complex **matrix1;\par
408     {\cf17 struct }Complex **rmtx;\par
409 \par
410      printf({\cf22 "======Teste da Operacao conjugada========\\n\\n"});\par
411 \par
412     {\cf20 // alocar mem\'F3ria para a matrizes}\par
413     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
414     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
415         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
416     \}\par
417 \par
418     {\cf20 // inicializar as matrizes}\par
419     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
420         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
421             matrix1[i][j].real = 1;\par
422             matrix1[i][j].img = 1;\par
423         \}\par
424     \}\par
425 \par
426     {\cf20 // imprimir a matrize operando}\par
427 \par
428     printf({\cf22 "Operando A:\\n\\n"});\par
429     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
430         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
431             printf({\cf22 "%.2fj\\t"},matrix1[i][j].img);\par
432         \}\par
433         printf({\cf22 "\\n\\n"});\par
434     \}\par
435 \par
436     {\cf20 // fazer a matriz conjugada usando a fun\'E7\'E3o auxiliar}\par
437     rmtx = conjugado(matrix1, linhas, colunas);\par
438 \par
439     {\cf20 // imprimir o conjugada da matriz}\par
440     printf({\cf22 "A conjugada da matriz:\\n\\n"});\par
441     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
442         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
443             printf({\cf22 "%.2fj\\t"},rmtx[i][j].img);\par
444         \}\par
445         printf({\cf22 "\\n\\n"});\par
446     \}\par
447 \par
448 \par
449     printf({\cf22 "Operando B:\\n\\n"});\par
450     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
451         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
452             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
453         \}\par
454         printf({\cf22 "\\n\\n"});\par
455     \}\par
456 \par
457     {\cf20 // fazer a matriz conjugada usando a fun\'E7\'E3o auxiliar}\par
458     rmtx = conjugado(matrix1, linhas, colunas);\par
459 \par
460     {\cf20 // imprimir o conjugada da matriz}\par
461     printf({\cf22 "A conjugada da matriz:\\n\\n"});\par
462     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
463         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
464             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
465         \}\par
466         printf({\cf22 "\\n\\n"});\par
467     \}\par
468 \par
469     {\cf20 // desalocar a mem\'F3ria alocada}\par
470     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
471         free(matrix1[i]);\par
472         free(rmtx[i]);\par
473     \}\par
474     free(matrix1);\par
475     free(rmtx);\par
476 \par
477     {\cf19 return} 0;\par
478 \}\par
}
}
{\xe \v teste_hermitiano\:matrizes.c}
{\xe \v matrizes.c\:teste_hermitiano}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int teste_hermitiano ()}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 506 \{\par
507     {\cf18 int} linhas = 3;\par
508     {\cf18 int} colunas = 3;\par
509     {\cf17 struct }Complex **matrix1;\par
510     {\cf17 struct }Complex **rmtx;\par
511 \par
512      printf({\cf22 "======Teste da Operacao hermitiano========\\n\\n"});\par
513 \par
514     {\cf20 // alocar mem\'F3ria para a matrizes}\par
515     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
516     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
517         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
518     \}\par
519 \par
520     {\cf20 // inicializar as matrizes}\par
521     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
522         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
523             matrix1[i][j].real = i;\par
524             matrix1[i][j].img = j;\par
525         \}\par
526     \}\par
527 \par
528     {\cf20 // imprimir a matrize operando}\par
529 \par
530     printf({\cf22 "Operando A:\\n\\n"});\par
531     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
532         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
533             printf({\cf22 "%.2fj\\t"}, matrix1[i][j].img);\par
534         \}\par
535         printf({\cf22 "\\n\\n"});\par
536     \}\par
537 \par
538     {\cf20 // fazer a matriz hermitiana usando a fun\'E7\'E3o auxiliar}\par
539     rmtx = hermitiano(matrix1, linhas, colunas);\par
540 \par
541     {\cf20 // imprimir o hermitiano da matriz}\par
542     printf({\cf22 "Hermitiano da matriz:\\n\\n"});\par
543     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
544         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
545             printf({\cf22 "%.2fj\\t"},rmtx[i][j].img);\par
546         \}\par
547         printf({\cf22 "\\n\\n"});\par
548     \}\par
549 \par
550 \par
551     printf({\cf22 "Operando B:\\n\\n"});\par
552     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
553         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
554             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
555         \}\par
556         printf({\cf22 "\\n\\n"});\par
557     \}\par
558 \par
559     {\cf20 // fazer a matriz hermitiana usando a fun\'E7\'E3o auxiliar}\par
560     rmtx = hermitiano(matrix1, linhas, colunas);\par
561 \par
562     {\cf20 // imprimir o hermitiano da matriz}\par
563     printf({\cf22 "Hermitiano da matriz:\\n\\n"});\par
564     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
565         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
566             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
567         \}\par
568         printf({\cf22 "\\n\\n"});\par
569     \}\par
570 \par
571     {\cf20 // desalocar a mem\'F3ria alocada}\par
572     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
573         free(matrix1[i]);\par
574         free(rmtx[i]);\par
575     \}\par
576     free(matrix1);\par
577     free(rmtx);\par
578 \par
579     {\cf19 return} 0;\par
580 \}\par
}
}
{\xe \v teste_produto_escalar\:matrizes.c}
{\xe \v matrizes.c\:teste_produto_escalar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int teste_produto_escalar ()}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 605                            \{\par
606     {\cf18 int} linhas = 3;\par
607     {\cf17 struct }Complex *vet1;\par
608     {\cf17 struct }Complex *vet2;\par
609     {\cf17 struct }Complex result;\par
610 \par
611      printf({\cf22 "======Teste da Operacao de Produto Escalar========\\n\\n"});\par
612 \par
613     {\cf20 // alocar mem\'F3ria para a matrizes}\par
614     vet1 = ({\cf17 struct }Complex *)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex ));\par
615     vet2 = ({\cf17 struct }Complex *)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex ));\par
616 \par
617     {\cf20 // inicializar os vetores}\par
618     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
619             vet1[i].real = 1;\par
620             vet1[i].img = 1;\par
621             vet2[i].real = 1;\par
622             vet2[i].img = 1;\par
623             \}\par
624     {\cf20 // imprimir os vetores operandos}\par
625 \par
626     printf({\cf22 "Operando A:\\n\\n"});\par
627     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
628             printf({\cf22 "%.2f\\t"},vet1[i].real);\par
629     \}\par
630 \par
631     printf({\cf22 "\\n\\n"});\par
632     printf({\cf22 "Operando B:\\n\\n"});\par
633     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
634             printf({\cf22 "%.2f\\t"},vet2[i].real);\par
635     \}\par
636 \par
637     printf({\cf22 "\\n\\n"});\par
638 \par
639     {\cf20 // fazer a matriz conjugada usando a fun\'E7\'E3o auxiliar}\par
640     result = produto_escalar(vet1, vet2, linhas,linhas);\par
641 \par
642     {\cf20 // imprimir o conjugada da matriz}\par
643     printf({\cf22 "Produto Escalar A . B:\\n\\n"});\par
644 \par
645 \par
646             printf({\cf22 "%.2f\\t"}, result.real);\par
647 \par
648         printf({\cf22 "\\n\\n"});\par
649 \par
650 \par
651     printf({\cf22 "Operando C:\\n\\n"});\par
652     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
653             printf({\cf22 "%.2f + %.2fj\\t"},vet1[i].real, vet1[i].img);\par
654     \}\par
655 \par
656     printf({\cf22 "\\n\\n"});\par
657     printf({\cf22 "Operando D:\\n\\n"});\par
658     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
659             printf({\cf22 "%.2f + %.2fj\\t"},vet2[i].real, vet2[i].img);\par
660     \}\par
661 \par
662     printf({\cf22 "\\n\\n"});\par
663 \par
664     {\cf20 // fazer a matriz conjugada usando a fun\'E7\'E3o auxiliar}\par
665     result = produto_escalar(vet1, vet2, linhas,linhas);\par
666 \par
667     {\cf20 // imprimir o conjugada da matriz}\par
668     printf({\cf22 "Produto Escalar C . D:\\n\\n"});\par
669 \par
670 \par
671             printf({\cf22 "%.2f + %.2fj\\t"}, result.real , result.img);\par
672 \par
673         printf({\cf22 "\\n\\n"});\par
674 \par
675     {\cf20 // desalocar a mem\'F3ria alocada}\par
676 \par
677     free(vet1);\par
678     free(vet2);\par
679 \par
680     {\cf19 return} 0;\par
681 \}\par
}
}
{\xe \v teste_produto_matricial\:matrizes.c}
{\xe \v matrizes.c\:teste_produto_matricial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int teste_produto_matricial ()}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 743 \{\par
744     {\cf18 int} linhas = 3;\par
745     {\cf18 int} colunas = 3;\par
746     {\cf17 struct }Complex **matrix1;\par
747     {\cf17 struct }Complex **matrix2;\par
748     {\cf17 struct }Complex **rmtx;\par
749 \par
750      printf({\cf22 "======Teste da Operacao de produto matricial========\\n\\n"});\par
751 \par
752     {\cf20 // alocar mem\'F3ria para as matrizes}\par
753 \par
754     {\cf19 if}(linhas==colunas)\{\par
755 \par
756     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
757     matrix2 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
758     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
759         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
760         matrix2[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
761     \}\par
762 \par
763     {\cf20 // inicializar as matrizes}\par
764     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
765         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
766             matrix1[i][j].real = 1;\par
767             matrix1[i][j].img = 1;\par
768             matrix2[i][j].real = -1;\par
769             matrix2[i][j].img = -1;\par
770         \}\par
771     \}\par
772 \par
773     {\cf20 // imprimir as matrizes operandas}\par
774 \par
775     printf({\cf22 "Operando A:\\n\\n"});\par
776     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
777         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
778             printf({\cf22 "%.2f\\t"}, matrix1[i][j].real);\par
779         \}\par
780         printf({\cf22 "\\n\\n"});\par
781     \}\par
782 \par
783     printf({\cf22 "Operando B:\\n\\n"});\par
784     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
785         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
786             printf({\cf22 "%.2f\\t"}, matrix2[i][j].real);\par
787         \}\par
788         printf({\cf22 "\\n\\n"});\par
789     \}\par
790 \par
791     {\cf20 // formar o produto das matrizes usando a fun\'E7\'E3o auxiliar}\par
792     rmtx = produto_matricial(matrix1, matrix2, linhas, colunas);\par
793 \par
794     {\cf20 // imprimir o produto matricial}\par
795     printf({\cf22 "A soma das matrizes :\\n\\n"});\par
796     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
797         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
798             printf({\cf22 "%.2f\\t"}, rmtx[i][j].real);\par
799         \}\par
800         printf({\cf22 "\\n\\n"});\par
801     \}\par
802 \par
803 \par
804 \par
805     printf({\cf22 "Operando C:\\n\\n"});\par
806     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
807         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
808             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
809         \}\par
810         printf({\cf22 "\\n\\n"});\par
811     \}\par
812 \par
813     printf({\cf22 "Operando D:\\n\\n"});\par
814     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
815         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
816             printf({\cf22 "%.2f + %.2fj\\t"}, matrix2[i][j].real, matrix2[i][j].img);\par
817         \}\par
818         printf({\cf22 "\\n\\n"});\par
819     \}\par
820 \par
821     {\cf20 // formar o produto das matrizes usando a fun\'E7\'E3o auxiliar}\par
822     rmtx = produto_matricial(matrix1, matrix2, linhas, colunas);\par
823 \par
824     {\cf20 // imprimir o produto matricial}\par
825     printf({\cf22 "A soma das matrizes :\\n\\n"});\par
826     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
827         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
828             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
829         \}\par
830         printf({\cf22 "\\n\\n"});\par
831     \}\par
832 \par
833     {\cf20 // desalocar a mem\'F3ria alocada}\par
834     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
835         free(matrix1[i]);\par
836         free(matrix2[i]);\par
837         free(rmtx[i]);\par
838     \}\par
839     free(matrix1);\par
840     free(matrix2);\par
841     free(rmtx);\par
842 \par
843     \}\par
844 \par
845     {\cf19 else}\{rmtx = produto_matricial(matrix1, matrix2, linhas, colunas);\}\par
846 \par
847 \par
848     {\cf19 return} 0;\par
849 \}\par
}
}
{\xe \v teste_soma\:matrizes.c}
{\xe \v matrizes.c\:teste_soma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int teste_soma ()}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 47 \{\par
48     {\cf18 int} linhas = 3;\par
49     {\cf18 int} colunas = 3;\par
50     {\cf17 struct }Complex **matrix1;\par
51     {\cf17 struct }Complex **matrix2;\par
52     {\cf17 struct }Complex **rmtx;\par
53 \par
54      printf({\cf22 "======Teste da Operacao de Soma========\\n\\n"});\par
55     {\cf19 if}(linhas == colunas)\{\par
56     {\cf20 // alocar mem\'F3ria para as matrizes}\par
57     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
58     matrix2 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
59     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
60         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
61         matrix2[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
62     \}\par
63 \par
64     {\cf20 // inicializar as matrizes}\par
65     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
66         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
67             matrix1[i][j].real = 1;\par
68             matrix1[i][j].img = 1;\par
69             matrix2[i][j].real = -1;\par
70             matrix2[i][j].img = -1;\par
71         \}\par
72     \}\par
73 \par
74     {\cf20 // imprimir as matrizes operandas}\par
75 \par
76 \par
77 \par
78     printf({\cf22 "Operando A:\\n\\n"});\par
79     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
80         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
81             printf({\cf22 "%.2f\\t"}, matrix1[i][j].real);\par
82         \}\par
83         printf({\cf22 "\\n\\n"});\par
84     \}\par
85 \par
86     printf({\cf22 "Operando B:\\n\\n"});\par
87     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
88         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
89             printf({\cf22 "%.2f\\t"}, matrix2[i][j].real);\par
90         \}\par
91         printf({\cf22 "\\n\\n"});\par
92     \}\par
93 \par
94     {\cf20 // somar as matrizes usando a fun\'E7\'E3o auxiliar}\par
95     rmtx = soma(matrix1, matrix2, linhas, colunas);\par
96 \par
97     {\cf20 // imprimir a soma das matrizes}\par
98     printf({\cf22 "A soma das matrizes :\\n\\n"});\par
99     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
100         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
101             printf({\cf22 "%.2f\\t"}, rmtx[i][j].real);\par
102         \}\par
103         printf({\cf22 "\\n\\n"});\par
104     \}\par
105 \par
106 \par
107 \par
108     printf({\cf22 "Operando C:\\n\\n"});\par
109     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
110         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
111             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
112         \}\par
113         printf({\cf22 "\\n\\n"});\par
114     \}\par
115 \par
116     printf({\cf22 "Operando D:\\n\\n"});\par
117     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
118         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
119             printf({\cf22 "%.2f + %.2fj\\t"}, matrix2[i][j].real, matrix2[i][j].img);\par
120         \}\par
121         printf({\cf22 "\\n\\n"});\par
122     \}\par
123 \par
124     {\cf20 // somar as matrizes usando a fun\'E7\'E3o auxiliar}\par
125     rmtx = soma(matrix1, matrix2, linhas, colunas);\par
126 \par
127     {\cf20 // imprimir a soma das matrizes}\par
128     printf({\cf22 "A soma das matrizes :\\n\\n"});\par
129     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
130         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
131             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
132         \}\par
133         printf({\cf22 "\\n\\n"});\par
134     \}\par
135 \par
136     {\cf20 // desalocar a mem\'F3ria alocada}\par
137     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
138         free(matrix1[i]);\par
139         free(matrix2[i]);\par
140         free(rmtx[i]);\par
141     \}\par
142     free(matrix1);\par
143     free(matrix2);\par
144     free(rmtx);\par
145     \}\par
146      {\cf19 else}\{\par
147 \par
148         printf({\cf22 "ERRO!\\n\\n"});\par
149         printf({\cf22 "A operacao de soma nao pode ser iniciada pois os elementos nao coincidem\\n\\n"});\par
150 \par
151     \}\par
152     {\cf19 return} 0;\par
153 \}\par
}
}
{\xe \v teste_subtracao\:matrizes.c}
{\xe \v matrizes.c\:teste_subtracao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int teste_subtracao ()}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 177 \{\par
178     {\cf18 int} linhas = 3;\par
179     {\cf18 int} colunas = 3;\par
180     {\cf17 struct }Complex **matrix1;\par
181     {\cf17 struct }Complex **matrix2;\par
182     {\cf17 struct }Complex **rmtx;\par
183 \par
184      printf({\cf22 "======Teste da Operacao de Subtracao========\\n\\n"});\par
185     {\cf19 if}(linhas == colunas)\{\par
186     {\cf20 // alocar mem\'F3ria para as matrizes}\par
187     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
188     matrix2 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
189     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
190         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
191         matrix2[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
192     \}\par
193 \par
194     {\cf20 // inicializar as matrizes}\par
195     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
196         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
197             matrix1[i][j].real = 1;\par
198             matrix1[i][j].img = 1;\par
199             matrix2[i][j].real = 1;\par
200             matrix2[i][j].img = 1;\par
201         \}\par
202     \}\par
203 \par
204     {\cf20 // imprimir as matrizes operandas}\par
205 \par
206     printf({\cf22 "Operando A:\\n\\n"});\par
207     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
208         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
209             printf({\cf22 "%.2f\\t"}, matrix1[i][j].real);\par
210         \}\par
211         printf({\cf22 "\\n\\n"});\par
212     \}\par
213 \par
214     printf({\cf22 "Operando B:\\n\\n"});\par
215     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
216         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
217             printf({\cf22 "%.2f\\t"}, matrix2[i][j].real);\par
218         \}\par
219         printf({\cf22 "\\n\\n"});\par
220     \}\par
221 \par
222     {\cf20 // somar as matrizes usando a fun\'E7\'E3o auxiliar}\par
223     rmtx = subtracao(matrix1, matrix2, linhas, colunas);\par
224 \par
225     {\cf20 // imprimir a soma das matrizes}\par
226     printf({\cf22 "A subtracao das matrizes :\\n\\n"});\par
227     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
228         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
229             printf({\cf22 "%.2f\\t"}, rmtx[i][j].real);\par
230         \}\par
231         printf({\cf22 "\\n\\n"});\par
232     \}\par
233 \par
234     printf({\cf22 "Operando C:\\n\\n"});\par
235     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
236         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
237             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
238         \}\par
239         printf({\cf22 "\\n\\n"});\par
240     \}\par
241 \par
242     printf({\cf22 "Operando D:\\n\\n"});\par
243     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
244         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
245             printf({\cf22 "%.2f + %.2fj\\t"}, matrix2[i][j].real, matrix2[i][j].img);\par
246         \}\par
247         printf({\cf22 "\\n\\n"});\par
248     \}\par
249 \par
250     {\cf20 // somar as matrizes usando a fun\'E7\'E3o auxiliar}\par
251     rmtx = subtracao(matrix1, matrix2, linhas, colunas);\par
252 \par
253     {\cf20 // imprimir a soma das matrizes}\par
254     printf({\cf22 "A subtracao das matrizes :\\n\\n"});\par
255     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
256         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
257             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
258         \}\par
259         printf({\cf22 "\\n\\n"});\par
260     \}\par
261 \par
262     {\cf20 // desalocar a mem\'F3ria alocada}\par
263     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
264         free(matrix1[i]);\par
265         free(matrix2[i]);\par
266         free(rmtx[i]);\par
267     \}\par
268     free(matrix1);\par
269     free(matrix2);\par
270     free(rmtx);\par
271     \}\par
272      {\cf19 else}\{\par
273 \par
274         printf({\cf22 "ERRO!\\n\\n"});\par
275         printf({\cf22 "A operacao de soma nao pode ser iniciada pois os elementos nao coincidem\\n\\n"});\par
276 \par
277     \}\par
278     {\cf19 return} 0;\par
279 \}\par
}
}
{\xe \v teste_todos\:matrizes.c}
{\xe \v matrizes.c\:teste_todos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
teste_todos ()}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 852 \{\par
853     printf({\cf22 "======Teste Geral========\\n\\n"});\par
854 \par
855     {\cf20 //FUN\'C7\'D5ES}\par
856     print_name();\par
857     teste_soma();\par
858     teste_subtracao();\par
859     teste_transposta();\par
860     teste_conjugada();\par
861     teste_hermitiano();\par
862     teste_produto_escalar();\par
863     teste_produto_matricial();\par
864 \}\par
}
}
{\xe \v teste_transposta\:matrizes.c}
{\xe \v matrizes.c\:teste_transposta}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int teste_transposta ()}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 305 \{\par
306     {\cf18 int} linhas = 3;\par
307     {\cf18 int} colunas = 3;\par
308     {\cf17 struct }Complex **matrix1;\par
309     {\cf17 struct }Complex **rmtx;\par
310 \par
311      printf({\cf22 "======Teste da Operacao transposta========\\n\\n"});\par
312 \par
313     {\cf20 // alocar mem\'F3ria para a matrizes}\par
314     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
315     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
316         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
317     \}\par
318 \par
319     {\cf20 // inicializar as matrizes}\par
320     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
321         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
322             matrix1[i][j].real = i;\par
323             matrix1[i][j].img = j;\par
324         \}\par
325     \}\par
326 \par
327     {\cf20 // imprimir a matrize operando}\par
328 \par
329     printf({\cf22 "Operando A:\\n\\n"});\par
330     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
331         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
332             printf({\cf22 "%.2f\\t"}, matrix1[i][j].real);\par
333         \}\par
334         printf({\cf22 "\\n\\n"});\par
335     \}\par
336 \par
337     {\cf20 // fazer a matriz transposta usando a fun\'E7\'E3o auxiliar}\par
338     rmtx = transposta(matrix1, linhas, colunas);\par
339 \par
340     {\cf20 // imprimir a matriz transposta}\par
341     printf({\cf22 "A transposta da matriz:\\n\\n"});\par
342     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
343         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
344             printf({\cf22 "%.2f\\t"}, rmtx[i][j].real);\par
345         \}\par
346         printf({\cf22 "\\n\\n"});\par
347     \}\par
348 \par
349 \par
350     printf({\cf22 "Operando B:\\n\\n"});\par
351     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
352         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
353             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
354         \}\par
355         printf({\cf22 "\\n\\n"});\par
356     \}\par
357 \par
358     {\cf20 // fazer a matriz transposta usando a fun\'E7\'E3o auxiliar}\par
359     rmtx = transposta(matrix1, linhas, colunas);\par
360 \par
361     {\cf20 // imprimir a matriz transposta}\par
362     printf({\cf22 "A transposta da matriz:\\n\\n"});\par
363     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
364         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
365             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
366         \}\par
367         printf({\cf22 "\\n\\n"});\par
368     \}\par
369 \par
370     {\cf20 // desalocar a mem\'F3ria alocada}\par
371     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
372         free(matrix1[i]);\par
373         free(rmtx[i]);\par
374     \}\par
375     free(matrix1);\par
376     free(rmtx);\par
377 \par
378     {\cf19 return} 0;\par
379 \}\par
}
}
{\xe \v transposta\:matrizes.c}
{\xe \v matrizes.c\:transposta}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} ** transposta (struct {\b Complex} **  {\i matrix1}, int  {\i linhas}, int  {\i colunas})}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 283 \{\par
284    {\cf17 struct }Complex **rmtx;\par
285    {\cf18 int} i,j;\par
286 \par
287     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
288     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
289     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
290         rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
291     \}\par
292 \par
293    {\cf19 for}(i = 0; i < linhas; i++)\par
294    \{\par
295        {\cf19 for}(j = 0; j < colunas; j++)\par
296        \{\par
297            rmtx[i][j].real = matrix1[j][i].real;\par
298            rmtx[i][j].img = matrix1[j][i].img;\par
299        \}\par
300    \}\par
301    {\cf19 return} rmtx;\par
302 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
matrizes.c\par \pard\plain 
{\tc\tcl2 \v D:/proj de engenharia/EngineeringProject2/matrizes.c}
{\xe \v D:/proj de engenharia/EngineeringProject2/matrizes.c}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Ir para a documenta\'E7\'E3o desse arquivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #include <stdio.h>}\par
2 {\cf21 #include <stdlib.h>}\par
3 {\cf21 #include "matrizes.h"}\par
4 \par
5 {\cf20 // FUNC\'D5ES}\par
6 \par
7 {\cf18 int} teste_produto_matricial();\par
8 \par
9 \par
10 print_name()\par
11 \{\par
12     printf({\cf22 "=====Equipe=====\\n\\n"});\par
13 \par
14         {\cf18 char} name1[]= {\cf22 "LUCAS ALEXSANDRO LEAL DOS SANTOS"};\par
15         {\cf18 char} name2[]= {\cf22 "GABRIEL DE JESUS DOS SANTOS COSTA"};\par
16         {\cf18 char} name3[]= {\cf22 "SAULO MATTHEUS RIBEIRO DE OLIVEIRA"};\par
17         {\cf18 char} name4[]= {\cf22 "JOSE HENRIQUE BARBOSA PENA"};\par
18 \par
19         printf({\cf22 " %s\\n %s\\n %s\\n %s\\n\\n"}, name1,name2, name3, name4);\par
20 \}\par
21 \par
22 {\cf17 struct }Complex **soma({\cf17 struct} Complex **matrix1,{\cf17 struct} Complex **matrix2, {\cf18 int} linhas, {\cf18 int} colunas)\par
23 \{\par
24 \par
25     {\cf17 struct }Complex **rmtx;\par
26     {\cf19 if}(linhas == colunas)\{\par
27     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
28     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
29     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
30         rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
31     \}\par
32 \par
33     {\cf20 // somar as matrizes}\par
34 \par
35     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
36         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
37             rmtx[i][j].real = matrix1[i][j].real + matrix2[i][j].real;\par
38             rmtx[i][j].img = matrix1[i][j].img + matrix2[i][j].img;\par
39         \}\par
40       \}\par
41     \}\par
42     {\cf19 return} rmtx;\par
43 \par
44 \}\par
45 \par
46 {\cf18 int} teste_soma()\par
47 \{\par
48     {\cf18 int} linhas = 3;\par
49     {\cf18 int} colunas = 3;\par
50     {\cf17 struct }Complex **matrix1;\par
51     {\cf17 struct }Complex **matrix2;\par
52     {\cf17 struct }Complex **rmtx;\par
53 \par
54      printf({\cf22 "======Teste da Operacao de Soma========\\n\\n"});\par
55     {\cf19 if}(linhas == colunas)\{\par
56     {\cf20 // alocar mem\'F3ria para as matrizes}\par
57     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
58     matrix2 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
59     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
60         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
61         matrix2[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
62     \}\par
63 \par
64     {\cf20 // inicializar as matrizes}\par
65     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
66         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
67             matrix1[i][j].real = 1;\par
68             matrix1[i][j].img = 1;\par
69             matrix2[i][j].real = -1;\par
70             matrix2[i][j].img = -1;\par
71         \}\par
72     \}\par
73 \par
74     {\cf20 // imprimir as matrizes operandas}\par
75 \par
76 \par
77 \par
78     printf({\cf22 "Operando A:\\n\\n"});\par
79     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
80         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
81             printf({\cf22 "%.2f\\t"}, matrix1[i][j].real);\par
82         \}\par
83         printf({\cf22 "\\n\\n"});\par
84     \}\par
85 \par
86     printf({\cf22 "Operando B:\\n\\n"});\par
87     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
88         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
89             printf({\cf22 "%.2f\\t"}, matrix2[i][j].real);\par
90         \}\par
91         printf({\cf22 "\\n\\n"});\par
92     \}\par
93 \par
94     {\cf20 // somar as matrizes usando a fun\'E7\'E3o auxiliar}\par
95     rmtx = soma(matrix1, matrix2, linhas, colunas);\par
96 \par
97     {\cf20 // imprimir a soma das matrizes}\par
98     printf({\cf22 "A soma das matrizes :\\n\\n"});\par
99     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
100         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
101             printf({\cf22 "%.2f\\t"}, rmtx[i][j].real);\par
102         \}\par
103         printf({\cf22 "\\n\\n"});\par
104     \}\par
105 \par
106 \par
107 \par
108     printf({\cf22 "Operando C:\\n\\n"});\par
109     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
110         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
111             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
112         \}\par
113         printf({\cf22 "\\n\\n"});\par
114     \}\par
115 \par
116     printf({\cf22 "Operando D:\\n\\n"});\par
117     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
118         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
119             printf({\cf22 "%.2f + %.2fj\\t"}, matrix2[i][j].real, matrix2[i][j].img);\par
120         \}\par
121         printf({\cf22 "\\n\\n"});\par
122     \}\par
123 \par
124     {\cf20 // somar as matrizes usando a fun\'E7\'E3o auxiliar}\par
125     rmtx = soma(matrix1, matrix2, linhas, colunas);\par
126 \par
127     {\cf20 // imprimir a soma das matrizes}\par
128     printf({\cf22 "A soma das matrizes :\\n\\n"});\par
129     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
130         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
131             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
132         \}\par
133         printf({\cf22 "\\n\\n"});\par
134     \}\par
135 \par
136     {\cf20 // desalocar a mem\'F3ria alocada}\par
137     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
138         free(matrix1[i]);\par
139         free(matrix2[i]);\par
140         free(rmtx[i]);\par
141     \}\par
142     free(matrix1);\par
143     free(matrix2);\par
144     free(rmtx);\par
145     \}\par
146      {\cf19 else}\{\par
147 \par
148         printf({\cf22 "ERRO!\\n\\n"});\par
149         printf({\cf22 "A operacao de soma nao pode ser iniciada pois os elementos nao coincidem\\n\\n"});\par
150 \par
151     \}\par
152     {\cf19 return} 0;\par
153 \}\par
154 \par
155 {\cf17 struct }Complex **subtracao({\cf17 struct} Complex **matrix1,{\cf17 struct} Complex **matrix2, {\cf18 int} linhas, {\cf18 int} colunas)\par
156 \{\par
157     {\cf17 struct }Complex **rmtx;\par
158     {\cf19 if}(linhas == colunas)\{\par
159     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
160     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
161     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
162         rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
163     \}\par
164 \par
165     {\cf20 // somar as matrizes}\par
166     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
167         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
168             rmtx[i][j].real = matrix1[i][j].real - matrix2[i][j].real;\par
169             rmtx[i][j].img = matrix1[i][j].img - matrix2[i][j].img;\par
170         \}\par
171     \}\par
172     \}\par
173     {\cf19 return} rmtx;\par
174 \}\par
175 \par
176 {\cf18 int} teste_subtracao()\par
177 \{\par
178     {\cf18 int} linhas = 3;\par
179     {\cf18 int} colunas = 3;\par
180     {\cf17 struct }Complex **matrix1;\par
181     {\cf17 struct }Complex **matrix2;\par
182     {\cf17 struct }Complex **rmtx;\par
183 \par
184      printf({\cf22 "======Teste da Operacao de Subtracao========\\n\\n"});\par
185     {\cf19 if}(linhas == colunas)\{\par
186     {\cf20 // alocar mem\'F3ria para as matrizes}\par
187     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
188     matrix2 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
189     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
190         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
191         matrix2[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
192     \}\par
193 \par
194     {\cf20 // inicializar as matrizes}\par
195     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
196         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
197             matrix1[i][j].real = 1;\par
198             matrix1[i][j].img = 1;\par
199             matrix2[i][j].real = 1;\par
200             matrix2[i][j].img = 1;\par
201         \}\par
202     \}\par
203 \par
204     {\cf20 // imprimir as matrizes operandas}\par
205 \par
206     printf({\cf22 "Operando A:\\n\\n"});\par
207     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
208         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
209             printf({\cf22 "%.2f\\t"}, matrix1[i][j].real);\par
210         \}\par
211         printf({\cf22 "\\n\\n"});\par
212     \}\par
213 \par
214     printf({\cf22 "Operando B:\\n\\n"});\par
215     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
216         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
217             printf({\cf22 "%.2f\\t"}, matrix2[i][j].real);\par
218         \}\par
219         printf({\cf22 "\\n\\n"});\par
220     \}\par
221 \par
222     {\cf20 // somar as matrizes usando a fun\'E7\'E3o auxiliar}\par
223     rmtx = subtracao(matrix1, matrix2, linhas, colunas);\par
224 \par
225     {\cf20 // imprimir a soma das matrizes}\par
226     printf({\cf22 "A subtracao das matrizes :\\n\\n"});\par
227     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
228         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
229             printf({\cf22 "%.2f\\t"}, rmtx[i][j].real);\par
230         \}\par
231         printf({\cf22 "\\n\\n"});\par
232     \}\par
233 \par
234     printf({\cf22 "Operando C:\\n\\n"});\par
235     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
236         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
237             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
238         \}\par
239         printf({\cf22 "\\n\\n"});\par
240     \}\par
241 \par
242     printf({\cf22 "Operando D:\\n\\n"});\par
243     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
244         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
245             printf({\cf22 "%.2f + %.2fj\\t"}, matrix2[i][j].real, matrix2[i][j].img);\par
246         \}\par
247         printf({\cf22 "\\n\\n"});\par
248     \}\par
249 \par
250     {\cf20 // somar as matrizes usando a fun\'E7\'E3o auxiliar}\par
251     rmtx = subtracao(matrix1, matrix2, linhas, colunas);\par
252 \par
253     {\cf20 // imprimir a soma das matrizes}\par
254     printf({\cf22 "A subtracao das matrizes :\\n\\n"});\par
255     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
256         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
257             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
258         \}\par
259         printf({\cf22 "\\n\\n"});\par
260     \}\par
261 \par
262     {\cf20 // desalocar a mem\'F3ria alocada}\par
263     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
264         free(matrix1[i]);\par
265         free(matrix2[i]);\par
266         free(rmtx[i]);\par
267     \}\par
268     free(matrix1);\par
269     free(matrix2);\par
270     free(rmtx);\par
271     \}\par
272      {\cf19 else}\{\par
273 \par
274         printf({\cf22 "ERRO!\\n\\n"});\par
275         printf({\cf22 "A operacao de soma nao pode ser iniciada pois os elementos nao coincidem\\n\\n"});\par
276 \par
277     \}\par
278     {\cf19 return} 0;\par
279 \}\par
280 \par
281 \par
282 {\cf17 struct }Complex **transposta({\cf17 struct} Complex **matrix1, {\cf18 int} linhas, {\cf18 int} colunas)\par
283 \{\par
284    {\cf17 struct }Complex **rmtx;\par
285    {\cf18 int} i,j;\par
286 \par
287     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
288     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
289     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
290         rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
291     \}\par
292 \par
293    {\cf19 for}(i = 0; i < linhas; i++)\par
294    \{\par
295        {\cf19 for}(j = 0; j < colunas; j++)\par
296        \{\par
297            rmtx[i][j].real = matrix1[j][i].real;\par
298            rmtx[i][j].img = matrix1[j][i].img;\par
299        \}\par
300    \}\par
301    {\cf19 return} rmtx;\par
302 \}\par
303 \par
304 {\cf18 int} teste_transposta()\par
305 \{\par
306     {\cf18 int} linhas = 3;\par
307     {\cf18 int} colunas = 3;\par
308     {\cf17 struct }Complex **matrix1;\par
309     {\cf17 struct }Complex **rmtx;\par
310 \par
311      printf({\cf22 "======Teste da Operacao transposta========\\n\\n"});\par
312 \par
313     {\cf20 // alocar mem\'F3ria para a matrizes}\par
314     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
315     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
316         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
317     \}\par
318 \par
319     {\cf20 // inicializar as matrizes}\par
320     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
321         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
322             matrix1[i][j].real = i;\par
323             matrix1[i][j].img = j;\par
324         \}\par
325     \}\par
326 \par
327     {\cf20 // imprimir a matrize operando}\par
328 \par
329     printf({\cf22 "Operando A:\\n\\n"});\par
330     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
331         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
332             printf({\cf22 "%.2f\\t"}, matrix1[i][j].real);\par
333         \}\par
334         printf({\cf22 "\\n\\n"});\par
335     \}\par
336 \par
337     {\cf20 // fazer a matriz transposta usando a fun\'E7\'E3o auxiliar}\par
338     rmtx = transposta(matrix1, linhas, colunas);\par
339 \par
340     {\cf20 // imprimir a matriz transposta}\par
341     printf({\cf22 "A transposta da matriz:\\n\\n"});\par
342     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
343         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
344             printf({\cf22 "%.2f\\t"}, rmtx[i][j].real);\par
345         \}\par
346         printf({\cf22 "\\n\\n"});\par
347     \}\par
348 \par
349 \par
350     printf({\cf22 "Operando B:\\n\\n"});\par
351     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
352         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
353             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
354         \}\par
355         printf({\cf22 "\\n\\n"});\par
356     \}\par
357 \par
358     {\cf20 // fazer a matriz transposta usando a fun\'E7\'E3o auxiliar}\par
359     rmtx = transposta(matrix1, linhas, colunas);\par
360 \par
361     {\cf20 // imprimir a matriz transposta}\par
362     printf({\cf22 "A transposta da matriz:\\n\\n"});\par
363     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
364         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
365             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
366         \}\par
367         printf({\cf22 "\\n\\n"});\par
368     \}\par
369 \par
370     {\cf20 // desalocar a mem\'F3ria alocada}\par
371     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
372         free(matrix1[i]);\par
373         free(rmtx[i]);\par
374     \}\par
375     free(matrix1);\par
376     free(rmtx);\par
377 \par
378     {\cf19 return} 0;\par
379 \}\par
380 \par
381 {\cf17 struct }Complex **conjugado({\cf17 struct} Complex **matrix1, {\cf18 int} linhas, {\cf18 int} colunas)\par
382 \{\par
383    {\cf17 struct }Complex **rmtx;\par
384    {\cf18 int} i,j;\par
385 \par
386     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
387     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
388     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
389         rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
390     \}\par
391 \par
392    {\cf19 for}(i = 0; i < linhas; i++)\par
393    \{\par
394        {\cf19 for}(j = 0; j < colunas; j++)\par
395        \{\par
396            rmtx[i][j].real = matrix1[i][j].real;\par
397            rmtx[i][j].img = matrix1[i][j].img * (-1);\par
398        \}\par
399    \}\par
400    {\cf19 return} rmtx;\par
401 \}\par
402 \par
403 {\cf18 int} teste_conjugada()\par
404 \{\par
405     {\cf18 int} linhas = 3;\par
406     {\cf18 int} colunas = 3;\par
407     {\cf17 struct }Complex **matrix1;\par
408     {\cf17 struct }Complex **rmtx;\par
409 \par
410      printf({\cf22 "======Teste da Operacao conjugada========\\n\\n"});\par
411 \par
412     {\cf20 // alocar mem\'F3ria para a matrizes}\par
413     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
414     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
415         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
416     \}\par
417 \par
418     {\cf20 // inicializar as matrizes}\par
419     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
420         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
421             matrix1[i][j].real = 1;\par
422             matrix1[i][j].img = 1;\par
423         \}\par
424     \}\par
425 \par
426     {\cf20 // imprimir a matrize operando}\par
427 \par
428     printf({\cf22 "Operando A:\\n\\n"});\par
429     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
430         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
431             printf({\cf22 "%.2fj\\t"},matrix1[i][j].img);\par
432         \}\par
433         printf({\cf22 "\\n\\n"});\par
434     \}\par
435 \par
436     {\cf20 // fazer a matriz conjugada usando a fun\'E7\'E3o auxiliar}\par
437     rmtx = conjugado(matrix1, linhas, colunas);\par
438 \par
439     {\cf20 // imprimir o conjugada da matriz}\par
440     printf({\cf22 "A conjugada da matriz:\\n\\n"});\par
441     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
442         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
443             printf({\cf22 "%.2fj\\t"},rmtx[i][j].img);\par
444         \}\par
445         printf({\cf22 "\\n\\n"});\par
446     \}\par
447 \par
448 \par
449     printf({\cf22 "Operando B:\\n\\n"});\par
450     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
451         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
452             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
453         \}\par
454         printf({\cf22 "\\n\\n"});\par
455     \}\par
456 \par
457     {\cf20 // fazer a matriz conjugada usando a fun\'E7\'E3o auxiliar}\par
458     rmtx = conjugado(matrix1, linhas, colunas);\par
459 \par
460     {\cf20 // imprimir o conjugada da matriz}\par
461     printf({\cf22 "A conjugada da matriz:\\n\\n"});\par
462     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
463         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
464             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
465         \}\par
466         printf({\cf22 "\\n\\n"});\par
467     \}\par
468 \par
469     {\cf20 // desalocar a mem\'F3ria alocada}\par
470     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
471         free(matrix1[i]);\par
472         free(rmtx[i]);\par
473     \}\par
474     free(matrix1);\par
475     free(rmtx);\par
476 \par
477     {\cf19 return} 0;\par
478 \}\par
479 \par
480 {\cf17 struct }Complex **hermitiano({\cf17 struct} Complex **matrix1, {\cf18 int} linhas, {\cf18 int} colunas)\par
481 \{\par
482    {\cf17 struct }Complex **rmtx, **aux;\par
483    {\cf18 int} i,j;\par
484 \par
485     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
486     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
487     aux = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
488 \par
489     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
490          rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
491          aux[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
492     \}\par
493 \par
494    {\cf19 for}(i = 0; i < linhas; i++)\par
495    \{\par
496        {\cf19 for}(j = 0; j < colunas; j++)\par
497        \{\par
498            aux=transposta(matrix1,linhas,colunas);\par
499            rmtx=conjugado(aux,linhas,colunas);\par
500        \}\par
501    \}\par
502    {\cf19 return} rmtx;\par
503 \}\par
504 \par
505 {\cf18 int} teste_hermitiano()\par
506 \{\par
507     {\cf18 int} linhas = 3;\par
508     {\cf18 int} colunas = 3;\par
509     {\cf17 struct }Complex **matrix1;\par
510     {\cf17 struct }Complex **rmtx;\par
511 \par
512      printf({\cf22 "======Teste da Operacao hermitiano========\\n\\n"});\par
513 \par
514     {\cf20 // alocar mem\'F3ria para a matrizes}\par
515     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
516     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
517         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
518     \}\par
519 \par
520     {\cf20 // inicializar as matrizes}\par
521     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
522         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
523             matrix1[i][j].real = i;\par
524             matrix1[i][j].img = j;\par
525         \}\par
526     \}\par
527 \par
528     {\cf20 // imprimir a matrize operando}\par
529 \par
530     printf({\cf22 "Operando A:\\n\\n"});\par
531     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
532         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
533             printf({\cf22 "%.2fj\\t"}, matrix1[i][j].img);\par
534         \}\par
535         printf({\cf22 "\\n\\n"});\par
536     \}\par
537 \par
538     {\cf20 // fazer a matriz hermitiana usando a fun\'E7\'E3o auxiliar}\par
539     rmtx = hermitiano(matrix1, linhas, colunas);\par
540 \par
541     {\cf20 // imprimir o hermitiano da matriz}\par
542     printf({\cf22 "Hermitiano da matriz:\\n\\n"});\par
543     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
544         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
545             printf({\cf22 "%.2fj\\t"},rmtx[i][j].img);\par
546         \}\par
547         printf({\cf22 "\\n\\n"});\par
548     \}\par
549 \par
550 \par
551     printf({\cf22 "Operando B:\\n\\n"});\par
552     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
553         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
554             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
555         \}\par
556         printf({\cf22 "\\n\\n"});\par
557     \}\par
558 \par
559     {\cf20 // fazer a matriz hermitiana usando a fun\'E7\'E3o auxiliar}\par
560     rmtx = hermitiano(matrix1, linhas, colunas);\par
561 \par
562     {\cf20 // imprimir o hermitiano da matriz}\par
563     printf({\cf22 "Hermitiano da matriz:\\n\\n"});\par
564     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
565         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
566             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
567         \}\par
568         printf({\cf22 "\\n\\n"});\par
569     \}\par
570 \par
571     {\cf20 // desalocar a mem\'F3ria alocada}\par
572     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
573         free(matrix1[i]);\par
574         free(rmtx[i]);\par
575     \}\par
576     free(matrix1);\par
577     free(rmtx);\par
578 \par
579     {\cf19 return} 0;\par
580 \}\par
581 \par
582 {\cf17 struct }Complex produto_escalar(struct Complex *vet1,{\cf17 struct }Complex *vet2, {\cf18 int} neu, {\cf18 int} nev)\{\par
583 {\cf17 struct }Complex rmtx, aux;\par
584 \par
585     rmtx.real= 0;\par
586     rmtx.img= 0;\par
587 \par
588     {\cf19 if}(neu == nev)\{\par
589     {\cf20 // multiplicar as matrizes}\par
590     {\cf19 for}({\cf18 int} i=0; i<neu; i++)\{\par
591             aux = multiplicacao(vet1[i],vet2[i]);\par
592             rmtx.real = rmtx.real + aux.real;\par
593             rmtx.img = rmtx.img + aux.img;\par
594             \}\par
595         \}\par
596      {\cf19 else}\{\par
597             printf({\cf22 "ERRO!\\n\\n"});\par
598             printf({\cf22 "O produto escalar nao pode ser calculado porque entre estes vetores pois o numero de elementos dos vetores nao coincidem.\\n\\n"});\par
599     \}\par
600 \par
601 \par
602     {\cf19 return} rmtx;\par
603 \}\par
604 \par
605 {\cf18 int} teste_produto_escalar()\{\par
606     {\cf18 int} linhas = 3;\par
607     {\cf17 struct }Complex *vet1;\par
608     {\cf17 struct }Complex *vet2;\par
609     {\cf17 struct }Complex result;\par
610 \par
611      printf({\cf22 "======Teste da Operacao de Produto Escalar========\\n\\n"});\par
612 \par
613     {\cf20 // alocar mem\'F3ria para a matrizes}\par
614     vet1 = ({\cf17 struct }Complex *)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex ));\par
615     vet2 = ({\cf17 struct }Complex *)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex ));\par
616 \par
617     {\cf20 // inicializar os vetores}\par
618     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
619             vet1[i].real = 1;\par
620             vet1[i].img = 1;\par
621             vet2[i].real = 1;\par
622             vet2[i].img = 1;\par
623             \}\par
624     {\cf20 // imprimir os vetores operandos}\par
625 \par
626     printf({\cf22 "Operando A:\\n\\n"});\par
627     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
628             printf({\cf22 "%.2f\\t"},vet1[i].real);\par
629     \}\par
630 \par
631     printf({\cf22 "\\n\\n"});\par
632     printf({\cf22 "Operando B:\\n\\n"});\par
633     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
634             printf({\cf22 "%.2f\\t"},vet2[i].real);\par
635     \}\par
636 \par
637     printf({\cf22 "\\n\\n"});\par
638 \par
639     {\cf20 // fazer a matriz conjugada usando a fun\'E7\'E3o auxiliar}\par
640     result = produto_escalar(vet1, vet2, linhas,linhas);\par
641 \par
642     {\cf20 // imprimir o conjugada da matriz}\par
643     printf({\cf22 "Produto Escalar A . B:\\n\\n"});\par
644 \par
645 \par
646             printf({\cf22 "%.2f\\t"}, result.real);\par
647 \par
648         printf({\cf22 "\\n\\n"});\par
649 \par
650 \par
651     printf({\cf22 "Operando C:\\n\\n"});\par
652     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
653             printf({\cf22 "%.2f + %.2fj\\t"},vet1[i].real, vet1[i].img);\par
654     \}\par
655 \par
656     printf({\cf22 "\\n\\n"});\par
657     printf({\cf22 "Operando D:\\n\\n"});\par
658     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
659             printf({\cf22 "%.2f + %.2fj\\t"},vet2[i].real, vet2[i].img);\par
660     \}\par
661 \par
662     printf({\cf22 "\\n\\n"});\par
663 \par
664     {\cf20 // fazer a matriz conjugada usando a fun\'E7\'E3o auxiliar}\par
665     result = produto_escalar(vet1, vet2, linhas,linhas);\par
666 \par
667     {\cf20 // imprimir o conjugada da matriz}\par
668     printf({\cf22 "Produto Escalar C . D:\\n\\n"});\par
669 \par
670 \par
671             printf({\cf22 "%.2f + %.2fj\\t"}, result.real , result.img);\par
672 \par
673         printf({\cf22 "\\n\\n"});\par
674 \par
675     {\cf20 // desalocar a mem\'F3ria alocada}\par
676 \par
677     free(vet1);\par
678     free(vet2);\par
679 \par
680     {\cf19 return} 0;\par
681 \}\par
682 \par
683 {\cf17 struct }Complex somanc(struct Complex a,struct Complex b) \{\par
684 \par
685     {\cf17 struct }Complex result;\par
686 \par
687     result.real = a.real + b.real;\par
688     result.img = a.img + b.img;\par
689 \par
690     {\cf19 return} result;\par
691 \}\par
692 \par
693 {\cf17 struct }Complex multiplicacao(struct Complex x,struct Complex y)\par
694 \{\par
695     {\cf17 struct }Complex rmtx;\par
696 \par
697     {\cf20 // multiplicar as matrizes}\par
698     {\cf19 for}({\cf18 int} i=0; i<1; i++)\{\par
699             rmtx.real = (x.real * y.real) + (x.img * y.img) * (-1);\par
700             rmtx.img = (x.real * y.img)  +  (x.img * y.real);\par
701     \}\par
702 \par
703     {\cf19 return} rmtx;\par
704 \}\par
705 \par
706 {\cf17 struct }Complex **produto_matricial({\cf17 struct} Complex **matrix1,{\cf17 struct} Complex **matrix2, {\cf18 int} linhas, {\cf18 int} colunas)\par
707 \{\par
708     {\cf17 struct }Complex **rmtx, aux, sum;\par
709 \par
710     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
711     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
712 \par
713     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
714         rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
715 \par
716     \}\par
717 \par
718     {\cf19 if}(linhas==colunas)\{\par
719 \par
720     {\cf20 // somar as matrizes}\par
721     {\cf19 for} ({\cf18 int} i = 0; i < linhas; i++) \{\par
722     {\cf19 for} ({\cf18 int} j = 0; j < colunas; j++) \{\par
723         sum.real = 0;\par
724         sum.img = 0;\par
725         {\cf19 for} ({\cf18 int} k = 0; k < colunas; k++) \{\par
726             aux = multiplicacao(matrix1[i][k], matrix2[k][j]);\par
727             sum = somanc(sum, aux);\par
728         \}\par
729         rmtx[i][j] = sum;\par
730     \}\par
731     \}\par
732     \}\par
733     {\cf19 else}\{\par
734 \par
735             printf({\cf22 "ERRO!\\n\\n"});\par
736             printf({\cf22 "A operacao de Produto Matricial nao pode ser iniciada porque o numero de linhas e colunas nao coincidem.\\n\\n"});\par
737 \par
738         \}\par
739     {\cf19 return} rmtx;\par
740 \}\par
741 \par
742 {\cf18 int} teste_produto_matricial()\par
743 \{\par
744     {\cf18 int} linhas = 3;\par
745     {\cf18 int} colunas = 3;\par
746     {\cf17 struct }Complex **matrix1;\par
747     {\cf17 struct }Complex **matrix2;\par
748     {\cf17 struct }Complex **rmtx;\par
749 \par
750      printf({\cf22 "======Teste da Operacao de produto matricial========\\n\\n"});\par
751 \par
752     {\cf20 // alocar mem\'F3ria para as matrizes}\par
753 \par
754     {\cf19 if}(linhas==colunas)\{\par
755 \par
756     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
757     matrix2 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
758     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
759         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
760         matrix2[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
761     \}\par
762 \par
763     {\cf20 // inicializar as matrizes}\par
764     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
765         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
766             matrix1[i][j].real = 1;\par
767             matrix1[i][j].img = 1;\par
768             matrix2[i][j].real = -1;\par
769             matrix2[i][j].img = -1;\par
770         \}\par
771     \}\par
772 \par
773     {\cf20 // imprimir as matrizes operandas}\par
774 \par
775     printf({\cf22 "Operando A:\\n\\n"});\par
776     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
777         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
778             printf({\cf22 "%.2f\\t"}, matrix1[i][j].real);\par
779         \}\par
780         printf({\cf22 "\\n\\n"});\par
781     \}\par
782 \par
783     printf({\cf22 "Operando B:\\n\\n"});\par
784     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
785         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
786             printf({\cf22 "%.2f\\t"}, matrix2[i][j].real);\par
787         \}\par
788         printf({\cf22 "\\n\\n"});\par
789     \}\par
790 \par
791     {\cf20 // formar o produto das matrizes usando a fun\'E7\'E3o auxiliar}\par
792     rmtx = produto_matricial(matrix1, matrix2, linhas, colunas);\par
793 \par
794     {\cf20 // imprimir o produto matricial}\par
795     printf({\cf22 "A soma das matrizes :\\n\\n"});\par
796     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
797         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
798             printf({\cf22 "%.2f\\t"}, rmtx[i][j].real);\par
799         \}\par
800         printf({\cf22 "\\n\\n"});\par
801     \}\par
802 \par
803 \par
804 \par
805     printf({\cf22 "Operando C:\\n\\n"});\par
806     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
807         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
808             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
809         \}\par
810         printf({\cf22 "\\n\\n"});\par
811     \}\par
812 \par
813     printf({\cf22 "Operando D:\\n\\n"});\par
814     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
815         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
816             printf({\cf22 "%.2f + %.2fj\\t"}, matrix2[i][j].real, matrix2[i][j].img);\par
817         \}\par
818         printf({\cf22 "\\n\\n"});\par
819     \}\par
820 \par
821     {\cf20 // formar o produto das matrizes usando a fun\'E7\'E3o auxiliar}\par
822     rmtx = produto_matricial(matrix1, matrix2, linhas, colunas);\par
823 \par
824     {\cf20 // imprimir o produto matricial}\par
825     printf({\cf22 "A soma das matrizes :\\n\\n"});\par
826     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
827         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
828             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
829         \}\par
830         printf({\cf22 "\\n\\n"});\par
831     \}\par
832 \par
833     {\cf20 // desalocar a mem\'F3ria alocada}\par
834     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
835         free(matrix1[i]);\par
836         free(matrix2[i]);\par
837         free(rmtx[i]);\par
838     \}\par
839     free(matrix1);\par
840     free(matrix2);\par
841     free(rmtx);\par
842 \par
843     \}\par
844 \par
845     {\cf19 else}\{rmtx = produto_matricial(matrix1, matrix2, linhas, colunas);\}\par
846 \par
847 \par
848     {\cf19 return} 0;\par
849 \}\par
850 \par
851 teste_todos()\par
852 \{\par
853     printf({\cf22 "======Teste Geral========\\n\\n"});\par
854 \par
855     {\cf20 //FUN\'C7\'D5ES}\par
856     print_name();\par
857     teste_soma();\par
858     teste_subtracao();\par
859     teste_transposta();\par
860     teste_conjugada();\par
861     teste_hermitiano();\par
862     teste_produto_escalar();\par
863     teste_produto_matricial();\par
864 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo D:/proj de engenharia/EngineeringProject2/matrizes.h\par \pard\plain 
{\tc\tcl2 \v D:/proj de engenharia/EngineeringProject2/matrizes.h}
{\xe \v D:/proj de engenharia/EngineeringProject2/matrizes.h}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b print_name} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} {\b somanc} (struct {\b Complex} a, struct {\b Complex} b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} {\b multiplicacao} (struct {\b Complex} x, struct {\b Complex} y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} ** {\b soma} (struct {\b Complex} **matrix1, struct {\b Complex} **matrix2, int linhas, int colunas)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b teste_soma} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} ** {\b subtracao} (struct {\b Complex} **matrix1, struct {\b Complex} **matrix2, int linhas, int colunas)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b teste_subtracao} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} ** {\b transposta} (struct {\b Complex} **matrix1, int linhas, int colunas)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b teste_transposta} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} ** {\b conjugado} (struct {\b Complex} **matrix1, int linhas, int colunas)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b teste_conjugada} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} ** {\b hermitiano} (struct {\b Complex} **matrix1, int linhas, int colunas)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b teste_hermitiana} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} {\b produto_escalar} (struct {\b Complex} *vet1, struct {\b Complex} *vet2, int neu, int nev)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b teste_produto_escalar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Complex} ** {\b produto_matricial} (struct {\b Complex} **matrix1, struct {\b Complex} **matrix2, int linhas, int colunas)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v conjugado\:matrizes.h}
{\xe \v matrizes.h\:conjugado}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} ** conjugado (struct {\b Complex} **  {\i matrix1}, int  {\i linhas}, int  {\i colunas})}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 382 \{\par
383    {\cf17 struct }Complex **rmtx;\par
384    {\cf18 int} i,j;\par
385 \par
386     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
387     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
388     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
389         rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
390     \}\par
391 \par
392    {\cf19 for}(i = 0; i < linhas; i++)\par
393    \{\par
394        {\cf19 for}(j = 0; j < colunas; j++)\par
395        \{\par
396            rmtx[i][j].real = matrix1[i][j].real;\par
397            rmtx[i][j].img = matrix1[i][j].img * (-1);\par
398        \}\par
399    \}\par
400    {\cf19 return} rmtx;\par
401 \}\par
}
}
{\xe \v hermitiano\:matrizes.h}
{\xe \v matrizes.h\:hermitiano}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} ** hermitiano (struct {\b Complex} **  {\i matrix1}, int  {\i linhas}, int  {\i colunas})}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 481 \{\par
482    {\cf17 struct }Complex **rmtx, **aux;\par
483    {\cf18 int} i,j;\par
484 \par
485     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
486     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
487     aux = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
488 \par
489     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
490          rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
491          aux[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
492     \}\par
493 \par
494    {\cf19 for}(i = 0; i < linhas; i++)\par
495    \{\par
496        {\cf19 for}(j = 0; j < colunas; j++)\par
497        \{\par
498            aux=transposta(matrix1,linhas,colunas);\par
499            rmtx=conjugado(aux,linhas,colunas);\par
500        \}\par
501    \}\par
502    {\cf19 return} rmtx;\par
503 \}\par
}
}
{\xe \v multiplicacao\:matrizes.h}
{\xe \v matrizes.h\:multiplicacao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} multiplicacao (struct {\b Complex}  {\i x}, struct {\b Complex}  {\i y})}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 694 \{\par
695     {\cf17 struct }Complex rmtx;\par
696 \par
697     {\cf20 // multiplicar as matrizes}\par
698     {\cf19 for}({\cf18 int} i=0; i<1; i++)\{\par
699             rmtx.real = (x.real * y.real) + (x.img * y.img) * (-1);\par
700             rmtx.img = (x.real * y.img)  +  (x.img * y.real);\par
701     \}\par
702 \par
703     {\cf19 return} rmtx;\par
704 \}\par
}
}
{\xe \v print_name\:matrizes.h}
{\xe \v matrizes.h\:print_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int print_name ()}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11 \{\par
12     printf({\cf22 "=====Equipe=====\\n\\n"});\par
13 \par
14         {\cf18 char} name1[]= {\cf22 "LUCAS ALEXSANDRO LEAL DOS SANTOS"};\par
15         {\cf18 char} name2[]= {\cf22 "GABRIEL DE JESUS DOS SANTOS COSTA"};\par
16         {\cf18 char} name3[]= {\cf22 "SAULO MATTHEUS RIBEIRO DE OLIVEIRA"};\par
17         {\cf18 char} name4[]= {\cf22 "JOSE HENRIQUE BARBOSA PENA"};\par
18 \par
19         printf({\cf22 " %s\\n %s\\n %s\\n %s\\n\\n"}, name1,name2, name3, name4);\par
20 \}\par
}
}
{\xe \v produto_escalar\:matrizes.h}
{\xe \v matrizes.h\:produto_escalar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} produto_escalar (struct {\b Complex} *  {\i vet1}, struct {\b Complex} *  {\i vet2}, int  {\i neu}, int  {\i nev})}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 582                                                                                            \{\par
583 {\cf17 struct }Complex rmtx, aux;\par
584 \par
585     rmtx.real= 0;\par
586     rmtx.img= 0;\par
587 \par
588     {\cf19 if}(neu == nev)\{\par
589     {\cf20 // multiplicar as matrizes}\par
590     {\cf19 for}({\cf18 int} i=0; i<neu; i++)\{\par
591             aux = multiplicacao(vet1[i],vet2[i]);\par
592             rmtx.real = rmtx.real + aux.real;\par
593             rmtx.img = rmtx.img + aux.img;\par
594             \}\par
595         \}\par
596      {\cf19 else}\{\par
597             printf({\cf22 "ERRO!\\n\\n"});\par
598             printf({\cf22 "O produto escalar nao pode ser calculado porque entre estes vetores pois o numero de elementos dos vetores nao coincidem.\\n\\n"});\par
599     \}\par
600 \par
601 \par
602     {\cf19 return} rmtx;\par
603 \}\par
}
}
{\xe \v produto_matricial\:matrizes.h}
{\xe \v matrizes.h\:produto_matricial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} ** produto_matricial (struct {\b Complex} **  {\i matrix1}, struct {\b Complex} **  {\i matrix2}, int  {\i linhas}, int  {\i colunas})}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 707 \{\par
708     {\cf17 struct }Complex **rmtx, aux, sum;\par
709 \par
710     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
711     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
712 \par
713     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
714         rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
715 \par
716     \}\par
717 \par
718     {\cf19 if}(linhas==colunas)\{\par
719 \par
720     {\cf20 // somar as matrizes}\par
721     {\cf19 for} ({\cf18 int} i = 0; i < linhas; i++) \{\par
722     {\cf19 for} ({\cf18 int} j = 0; j < colunas; j++) \{\par
723         sum.real = 0;\par
724         sum.img = 0;\par
725         {\cf19 for} ({\cf18 int} k = 0; k < colunas; k++) \{\par
726             aux = multiplicacao(matrix1[i][k], matrix2[k][j]);\par
727             sum = somanc(sum, aux);\par
728         \}\par
729         rmtx[i][j] = sum;\par
730     \}\par
731     \}\par
732     \}\par
733     {\cf19 else}\{\par
734 \par
735             printf({\cf22 "ERRO!\\n\\n"});\par
736             printf({\cf22 "A operacao de Produto Matricial nao pode ser iniciada porque o numero de linhas e colunas nao coincidem.\\n\\n"});\par
737 \par
738         \}\par
739     {\cf19 return} rmtx;\par
740 \}\par
}
}
{\xe \v soma\:matrizes.h}
{\xe \v matrizes.h\:soma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} ** soma (struct {\b Complex} **  {\i matrix1}, struct {\b Complex} **  {\i matrix2}, int  {\i linhas}, int  {\i colunas})}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23 \{\par
24 \par
25     {\cf17 struct }Complex **rmtx;\par
26     {\cf19 if}(linhas == colunas)\{\par
27     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
28     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
29     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
30         rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
31     \}\par
32 \par
33     {\cf20 // somar as matrizes}\par
34 \par
35     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
36         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
37             rmtx[i][j].real = matrix1[i][j].real + matrix2[i][j].real;\par
38             rmtx[i][j].img = matrix1[i][j].img + matrix2[i][j].img;\par
39         \}\par
40       \}\par
41     \}\par
42     {\cf19 return} rmtx;\par
43 \par
44 \}\par
}
}
{\xe \v somanc\:matrizes.h}
{\xe \v matrizes.h\:somanc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} somanc (struct {\b Complex}  {\i a}, struct {\b Complex}  {\i b})}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 683                                                          \{\par
684 \par
685     {\cf17 struct }Complex result;\par
686 \par
687     result.real = a.real + b.real;\par
688     result.img = a.img + b.img;\par
689 \par
690     {\cf19 return} result;\par
691 \}\par
}
}
{\xe \v subtracao\:matrizes.h}
{\xe \v matrizes.h\:subtracao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} ** subtracao (struct {\b Complex} **  {\i matrix1}, struct {\b Complex} **  {\i matrix2}, int  {\i linhas}, int  {\i colunas})}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 156 \{\par
157     {\cf17 struct }Complex **rmtx;\par
158     {\cf19 if}(linhas == colunas)\{\par
159     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
160     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
161     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
162         rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
163     \}\par
164 \par
165     {\cf20 // somar as matrizes}\par
166     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
167         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
168             rmtx[i][j].real = matrix1[i][j].real - matrix2[i][j].real;\par
169             rmtx[i][j].img = matrix1[i][j].img - matrix2[i][j].img;\par
170         \}\par
171     \}\par
172     \}\par
173     {\cf19 return} rmtx;\par
174 \}\par
}
}
{\xe \v teste_conjugada\:matrizes.h}
{\xe \v matrizes.h\:teste_conjugada}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int teste_conjugada ()}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 404 \{\par
405     {\cf18 int} linhas = 3;\par
406     {\cf18 int} colunas = 3;\par
407     {\cf17 struct }Complex **matrix1;\par
408     {\cf17 struct }Complex **rmtx;\par
409 \par
410      printf({\cf22 "======Teste da Operacao conjugada========\\n\\n"});\par
411 \par
412     {\cf20 // alocar mem\'F3ria para a matrizes}\par
413     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
414     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
415         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
416     \}\par
417 \par
418     {\cf20 // inicializar as matrizes}\par
419     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
420         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
421             matrix1[i][j].real = 1;\par
422             matrix1[i][j].img = 1;\par
423         \}\par
424     \}\par
425 \par
426     {\cf20 // imprimir a matrize operando}\par
427 \par
428     printf({\cf22 "Operando A:\\n\\n"});\par
429     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
430         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
431             printf({\cf22 "%.2fj\\t"},matrix1[i][j].img);\par
432         \}\par
433         printf({\cf22 "\\n\\n"});\par
434     \}\par
435 \par
436     {\cf20 // fazer a matriz conjugada usando a fun\'E7\'E3o auxiliar}\par
437     rmtx = conjugado(matrix1, linhas, colunas);\par
438 \par
439     {\cf20 // imprimir o conjugada da matriz}\par
440     printf({\cf22 "A conjugada da matriz:\\n\\n"});\par
441     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
442         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
443             printf({\cf22 "%.2fj\\t"},rmtx[i][j].img);\par
444         \}\par
445         printf({\cf22 "\\n\\n"});\par
446     \}\par
447 \par
448 \par
449     printf({\cf22 "Operando B:\\n\\n"});\par
450     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
451         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
452             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
453         \}\par
454         printf({\cf22 "\\n\\n"});\par
455     \}\par
456 \par
457     {\cf20 // fazer a matriz conjugada usando a fun\'E7\'E3o auxiliar}\par
458     rmtx = conjugado(matrix1, linhas, colunas);\par
459 \par
460     {\cf20 // imprimir o conjugada da matriz}\par
461     printf({\cf22 "A conjugada da matriz:\\n\\n"});\par
462     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
463         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
464             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
465         \}\par
466         printf({\cf22 "\\n\\n"});\par
467     \}\par
468 \par
469     {\cf20 // desalocar a mem\'F3ria alocada}\par
470     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
471         free(matrix1[i]);\par
472         free(rmtx[i]);\par
473     \}\par
474     free(matrix1);\par
475     free(rmtx);\par
476 \par
477     {\cf19 return} 0;\par
478 \}\par
}
}
{\xe \v teste_hermitiana\:matrizes.h}
{\xe \v matrizes.h\:teste_hermitiana}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int teste_hermitiana ()}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v teste_produto_escalar\:matrizes.h}
{\xe \v matrizes.h\:teste_produto_escalar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int teste_produto_escalar ()}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 605                            \{\par
606     {\cf18 int} linhas = 3;\par
607     {\cf17 struct }Complex *vet1;\par
608     {\cf17 struct }Complex *vet2;\par
609     {\cf17 struct }Complex result;\par
610 \par
611      printf({\cf22 "======Teste da Operacao de Produto Escalar========\\n\\n"});\par
612 \par
613     {\cf20 // alocar mem\'F3ria para a matrizes}\par
614     vet1 = ({\cf17 struct }Complex *)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex ));\par
615     vet2 = ({\cf17 struct }Complex *)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex ));\par
616 \par
617     {\cf20 // inicializar os vetores}\par
618     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
619             vet1[i].real = 1;\par
620             vet1[i].img = 1;\par
621             vet2[i].real = 1;\par
622             vet2[i].img = 1;\par
623             \}\par
624     {\cf20 // imprimir os vetores operandos}\par
625 \par
626     printf({\cf22 "Operando A:\\n\\n"});\par
627     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
628             printf({\cf22 "%.2f\\t"},vet1[i].real);\par
629     \}\par
630 \par
631     printf({\cf22 "\\n\\n"});\par
632     printf({\cf22 "Operando B:\\n\\n"});\par
633     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
634             printf({\cf22 "%.2f\\t"},vet2[i].real);\par
635     \}\par
636 \par
637     printf({\cf22 "\\n\\n"});\par
638 \par
639     {\cf20 // fazer a matriz conjugada usando a fun\'E7\'E3o auxiliar}\par
640     result = produto_escalar(vet1, vet2, linhas,linhas);\par
641 \par
642     {\cf20 // imprimir o conjugada da matriz}\par
643     printf({\cf22 "Produto Escalar A . B:\\n\\n"});\par
644 \par
645 \par
646             printf({\cf22 "%.2f\\t"}, result.real);\par
647 \par
648         printf({\cf22 "\\n\\n"});\par
649 \par
650 \par
651     printf({\cf22 "Operando C:\\n\\n"});\par
652     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
653             printf({\cf22 "%.2f + %.2fj\\t"},vet1[i].real, vet1[i].img);\par
654     \}\par
655 \par
656     printf({\cf22 "\\n\\n"});\par
657     printf({\cf22 "Operando D:\\n\\n"});\par
658     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
659             printf({\cf22 "%.2f + %.2fj\\t"},vet2[i].real, vet2[i].img);\par
660     \}\par
661 \par
662     printf({\cf22 "\\n\\n"});\par
663 \par
664     {\cf20 // fazer a matriz conjugada usando a fun\'E7\'E3o auxiliar}\par
665     result = produto_escalar(vet1, vet2, linhas,linhas);\par
666 \par
667     {\cf20 // imprimir o conjugada da matriz}\par
668     printf({\cf22 "Produto Escalar C . D:\\n\\n"});\par
669 \par
670 \par
671             printf({\cf22 "%.2f + %.2fj\\t"}, result.real , result.img);\par
672 \par
673         printf({\cf22 "\\n\\n"});\par
674 \par
675     {\cf20 // desalocar a mem\'F3ria alocada}\par
676 \par
677     free(vet1);\par
678     free(vet2);\par
679 \par
680     {\cf19 return} 0;\par
681 \}\par
}
}
{\xe \v teste_soma\:matrizes.h}
{\xe \v matrizes.h\:teste_soma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int teste_soma ()}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 47 \{\par
48     {\cf18 int} linhas = 3;\par
49     {\cf18 int} colunas = 3;\par
50     {\cf17 struct }Complex **matrix1;\par
51     {\cf17 struct }Complex **matrix2;\par
52     {\cf17 struct }Complex **rmtx;\par
53 \par
54      printf({\cf22 "======Teste da Operacao de Soma========\\n\\n"});\par
55     {\cf19 if}(linhas == colunas)\{\par
56     {\cf20 // alocar mem\'F3ria para as matrizes}\par
57     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
58     matrix2 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
59     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
60         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
61         matrix2[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
62     \}\par
63 \par
64     {\cf20 // inicializar as matrizes}\par
65     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
66         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
67             matrix1[i][j].real = 1;\par
68             matrix1[i][j].img = 1;\par
69             matrix2[i][j].real = -1;\par
70             matrix2[i][j].img = -1;\par
71         \}\par
72     \}\par
73 \par
74     {\cf20 // imprimir as matrizes operandas}\par
75 \par
76 \par
77 \par
78     printf({\cf22 "Operando A:\\n\\n"});\par
79     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
80         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
81             printf({\cf22 "%.2f\\t"}, matrix1[i][j].real);\par
82         \}\par
83         printf({\cf22 "\\n\\n"});\par
84     \}\par
85 \par
86     printf({\cf22 "Operando B:\\n\\n"});\par
87     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
88         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
89             printf({\cf22 "%.2f\\t"}, matrix2[i][j].real);\par
90         \}\par
91         printf({\cf22 "\\n\\n"});\par
92     \}\par
93 \par
94     {\cf20 // somar as matrizes usando a fun\'E7\'E3o auxiliar}\par
95     rmtx = soma(matrix1, matrix2, linhas, colunas);\par
96 \par
97     {\cf20 // imprimir a soma das matrizes}\par
98     printf({\cf22 "A soma das matrizes :\\n\\n"});\par
99     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
100         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
101             printf({\cf22 "%.2f\\t"}, rmtx[i][j].real);\par
102         \}\par
103         printf({\cf22 "\\n\\n"});\par
104     \}\par
105 \par
106 \par
107 \par
108     printf({\cf22 "Operando C:\\n\\n"});\par
109     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
110         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
111             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
112         \}\par
113         printf({\cf22 "\\n\\n"});\par
114     \}\par
115 \par
116     printf({\cf22 "Operando D:\\n\\n"});\par
117     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
118         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
119             printf({\cf22 "%.2f + %.2fj\\t"}, matrix2[i][j].real, matrix2[i][j].img);\par
120         \}\par
121         printf({\cf22 "\\n\\n"});\par
122     \}\par
123 \par
124     {\cf20 // somar as matrizes usando a fun\'E7\'E3o auxiliar}\par
125     rmtx = soma(matrix1, matrix2, linhas, colunas);\par
126 \par
127     {\cf20 // imprimir a soma das matrizes}\par
128     printf({\cf22 "A soma das matrizes :\\n\\n"});\par
129     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
130         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
131             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
132         \}\par
133         printf({\cf22 "\\n\\n"});\par
134     \}\par
135 \par
136     {\cf20 // desalocar a mem\'F3ria alocada}\par
137     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
138         free(matrix1[i]);\par
139         free(matrix2[i]);\par
140         free(rmtx[i]);\par
141     \}\par
142     free(matrix1);\par
143     free(matrix2);\par
144     free(rmtx);\par
145     \}\par
146      {\cf19 else}\{\par
147 \par
148         printf({\cf22 "ERRO!\\n\\n"});\par
149         printf({\cf22 "A operacao de soma nao pode ser iniciada pois os elementos nao coincidem\\n\\n"});\par
150 \par
151     \}\par
152     {\cf19 return} 0;\par
153 \}\par
}
}
{\xe \v teste_subtracao\:matrizes.h}
{\xe \v matrizes.h\:teste_subtracao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int teste_subtracao ()}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 177 \{\par
178     {\cf18 int} linhas = 3;\par
179     {\cf18 int} colunas = 3;\par
180     {\cf17 struct }Complex **matrix1;\par
181     {\cf17 struct }Complex **matrix2;\par
182     {\cf17 struct }Complex **rmtx;\par
183 \par
184      printf({\cf22 "======Teste da Operacao de Subtracao========\\n\\n"});\par
185     {\cf19 if}(linhas == colunas)\{\par
186     {\cf20 // alocar mem\'F3ria para as matrizes}\par
187     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
188     matrix2 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
189     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
190         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
191         matrix2[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
192     \}\par
193 \par
194     {\cf20 // inicializar as matrizes}\par
195     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
196         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
197             matrix1[i][j].real = 1;\par
198             matrix1[i][j].img = 1;\par
199             matrix2[i][j].real = 1;\par
200             matrix2[i][j].img = 1;\par
201         \}\par
202     \}\par
203 \par
204     {\cf20 // imprimir as matrizes operandas}\par
205 \par
206     printf({\cf22 "Operando A:\\n\\n"});\par
207     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
208         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
209             printf({\cf22 "%.2f\\t"}, matrix1[i][j].real);\par
210         \}\par
211         printf({\cf22 "\\n\\n"});\par
212     \}\par
213 \par
214     printf({\cf22 "Operando B:\\n\\n"});\par
215     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
216         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
217             printf({\cf22 "%.2f\\t"}, matrix2[i][j].real);\par
218         \}\par
219         printf({\cf22 "\\n\\n"});\par
220     \}\par
221 \par
222     {\cf20 // somar as matrizes usando a fun\'E7\'E3o auxiliar}\par
223     rmtx = subtracao(matrix1, matrix2, linhas, colunas);\par
224 \par
225     {\cf20 // imprimir a soma das matrizes}\par
226     printf({\cf22 "A subtracao das matrizes :\\n\\n"});\par
227     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
228         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
229             printf({\cf22 "%.2f\\t"}, rmtx[i][j].real);\par
230         \}\par
231         printf({\cf22 "\\n\\n"});\par
232     \}\par
233 \par
234     printf({\cf22 "Operando C:\\n\\n"});\par
235     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
236         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
237             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
238         \}\par
239         printf({\cf22 "\\n\\n"});\par
240     \}\par
241 \par
242     printf({\cf22 "Operando D:\\n\\n"});\par
243     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
244         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
245             printf({\cf22 "%.2f + %.2fj\\t"}, matrix2[i][j].real, matrix2[i][j].img);\par
246         \}\par
247         printf({\cf22 "\\n\\n"});\par
248     \}\par
249 \par
250     {\cf20 // somar as matrizes usando a fun\'E7\'E3o auxiliar}\par
251     rmtx = subtracao(matrix1, matrix2, linhas, colunas);\par
252 \par
253     {\cf20 // imprimir a soma das matrizes}\par
254     printf({\cf22 "A subtracao das matrizes :\\n\\n"});\par
255     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
256         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
257             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
258         \}\par
259         printf({\cf22 "\\n\\n"});\par
260     \}\par
261 \par
262     {\cf20 // desalocar a mem\'F3ria alocada}\par
263     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
264         free(matrix1[i]);\par
265         free(matrix2[i]);\par
266         free(rmtx[i]);\par
267     \}\par
268     free(matrix1);\par
269     free(matrix2);\par
270     free(rmtx);\par
271     \}\par
272      {\cf19 else}\{\par
273 \par
274         printf({\cf22 "ERRO!\\n\\n"});\par
275         printf({\cf22 "A operacao de soma nao pode ser iniciada pois os elementos nao coincidem\\n\\n"});\par
276 \par
277     \}\par
278     {\cf19 return} 0;\par
279 \}\par
}
}
{\xe \v teste_transposta\:matrizes.h}
{\xe \v matrizes.h\:teste_transposta}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int teste_transposta ()}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 305 \{\par
306     {\cf18 int} linhas = 3;\par
307     {\cf18 int} colunas = 3;\par
308     {\cf17 struct }Complex **matrix1;\par
309     {\cf17 struct }Complex **rmtx;\par
310 \par
311      printf({\cf22 "======Teste da Operacao transposta========\\n\\n"});\par
312 \par
313     {\cf20 // alocar mem\'F3ria para a matrizes}\par
314     matrix1 = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
315     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
316         matrix1[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
317     \}\par
318 \par
319     {\cf20 // inicializar as matrizes}\par
320     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
321         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
322             matrix1[i][j].real = i;\par
323             matrix1[i][j].img = j;\par
324         \}\par
325     \}\par
326 \par
327     {\cf20 // imprimir a matrize operando}\par
328 \par
329     printf({\cf22 "Operando A:\\n\\n"});\par
330     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
331         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
332             printf({\cf22 "%.2f\\t"}, matrix1[i][j].real);\par
333         \}\par
334         printf({\cf22 "\\n\\n"});\par
335     \}\par
336 \par
337     {\cf20 // fazer a matriz transposta usando a fun\'E7\'E3o auxiliar}\par
338     rmtx = transposta(matrix1, linhas, colunas);\par
339 \par
340     {\cf20 // imprimir a matriz transposta}\par
341     printf({\cf22 "A transposta da matriz:\\n\\n"});\par
342     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
343         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
344             printf({\cf22 "%.2f\\t"}, rmtx[i][j].real);\par
345         \}\par
346         printf({\cf22 "\\n\\n"});\par
347     \}\par
348 \par
349 \par
350     printf({\cf22 "Operando B:\\n\\n"});\par
351     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
352         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
353             printf({\cf22 "%.2f + %.2fj\\t"}, matrix1[i][j].real, matrix1[i][j].img);\par
354         \}\par
355         printf({\cf22 "\\n\\n"});\par
356     \}\par
357 \par
358     {\cf20 // fazer a matriz transposta usando a fun\'E7\'E3o auxiliar}\par
359     rmtx = transposta(matrix1, linhas, colunas);\par
360 \par
361     {\cf20 // imprimir a matriz transposta}\par
362     printf({\cf22 "A transposta da matriz:\\n\\n"});\par
363     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
364         {\cf19 for}({\cf18 int} j=0; j<colunas; j++)\{\par
365             printf({\cf22 "%.2f + %.2fj\\t"}, rmtx[i][j].real, rmtx[i][j].img);\par
366         \}\par
367         printf({\cf22 "\\n\\n"});\par
368     \}\par
369 \par
370     {\cf20 // desalocar a mem\'F3ria alocada}\par
371     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
372         free(matrix1[i]);\par
373         free(rmtx[i]);\par
374     \}\par
375     free(matrix1);\par
376     free(rmtx);\par
377 \par
378     {\cf19 return} 0;\par
379 \}\par
}
}
{\xe \v transposta\:matrizes.h}
{\xe \v matrizes.h\:transposta}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b Complex} ** transposta (struct {\b Complex} **  {\i matrix1}, int  {\i linhas}, int  {\i colunas})}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 283 \{\par
284    {\cf17 struct }Complex **rmtx;\par
285    {\cf18 int} i,j;\par
286 \par
287     {\cf20 // aloca mem\'F3ria para a matriz de sa\'EDda}\par
288     rmtx = ({\cf17 struct }Complex **)malloc(linhas * {\cf17 sizeof}({\cf17 struct} Complex *));\par
289     {\cf19 for}({\cf18 int} i=0; i<linhas; i++)\{\par
290         rmtx[i] = ({\cf17 struct }Complex *)malloc(colunas * {\cf17 sizeof}({\cf17 struct} Complex));\par
291     \}\par
292 \par
293    {\cf19 for}(i = 0; i < linhas; i++)\par
294    \{\par
295        {\cf19 for}(j = 0; j < colunas; j++)\par
296        \{\par
297            rmtx[i][j].real = matrix1[j][i].real;\par
298            rmtx[i][j].img = matrix1[j][i].img;\par
299        \}\par
300    \}\par
301    {\cf19 return} rmtx;\par
302 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
matrizes.h\par \pard\plain 
{\tc\tcl2 \v D:/proj de engenharia/EngineeringProject2/matrizes.h}
{\xe \v D:/proj de engenharia/EngineeringProject2/matrizes.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Ir para a documenta\'E7\'E3o desse arquivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef MATRIZES_H}\par
2 {\cf21 #define MATRIZES_H}\par
3 \par
4 {\cf17 typedef} {\cf17 struct }Complex\par
5 \{\par
6 \par
7     {\cf18 double} real;\par
8     {\cf18 double} img;\par
9 \par
10 \};\par
11 \par
12 {\cf18 int} print_name();\par
13 \par
14 {\cf17 struct }Complex somanc(struct Complex a,struct Complex b);\par
15 {\cf17 struct }Complex multiplicacao(struct Complex x,struct Complex y);\par
16 \par
17 {\cf17 struct }Complex **soma({\cf17 struct} Complex **matrix1,{\cf17 struct} Complex **matrix2, {\cf18 int} linhas, {\cf18 int} colunas);\par
18 {\cf18 int} teste_soma();\par
19 \par
20 {\cf17 struct }Complex **subtracao({\cf17 struct} Complex **matrix1,{\cf17 struct} Complex **matrix2, {\cf18 int} linhas, {\cf18 int} colunas);\par
21 {\cf18 int} teste_subtracao();\par
22 \par
23 {\cf17 struct }Complex **transposta({\cf17 struct} Complex **matrix1, {\cf18 int} linhas, {\cf18 int} colunas);\par
24 {\cf18 int} teste_transposta();\par
25 \par
26 {\cf17 struct }Complex **conjugado({\cf17 struct} Complex **matrix1, {\cf18 int} linhas, {\cf18 int} colunas);\par
27 {\cf18 int} teste_conjugada();\par
28 \par
29 {\cf17 struct }Complex **hermitiano({\cf17 struct} Complex **matrix1, {\cf18 int} linhas, {\cf18 int} colunas);\par
30 {\cf18 int} teste_hermitiana();\par
31 \par
32 {\cf17 struct }Complex produto_escalar(struct Complex *vet1,{\cf17 struct }Complex *vet2, {\cf18 int} neu, {\cf18 int} nev);\par
33 {\cf18 int} teste_produto_escalar();\par
34 \par
35 {\cf17 struct }Complex **produto_matricial({\cf17 struct} Complex **matrix1,{\cf17 struct} Complex **matrix2, {\cf18 int} linhas, {\cf18 int} colunas);\par
36 \par
37 {\cf21 #endif}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Sum\'E1rio\par 
\pard\plain 
{\tc \v Sum\'E1rio}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
